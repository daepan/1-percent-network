# 1주차
## URL
* Uniform Resource Locator의 약자
* 웹 상의 자원(Resource)의 위치(Locator)를 표준화(Uniform)된 방식으로 지정하는 주소이다.
<br><br>

## URL의 구성
<br>

1. 프로토콜
2. 도메인 이름
3. 포트
4. 경로
5. 쿼리 문자열
6. 프래그먼트
<br>

>예시 URL: https://www.example.com:443/path/to/resource?query=value#fragment
<br>

* https는 프로토콜.
* www.example.com는 도메인 이름.
* 443은 포트 번호. (HTTPS의 기본 포트이므로 대부분의 URL에서는 생략)
* /path/to/resource는 경로.
* ?query=value는 쿼리 문자열.
* #fragment는 프래그먼트.
<br>

현재 학습하고 있는 구간에서는 프로토콜, 경로, 도메인 이름 부분을 주로 설명하기에 이 부분을 먼저 설명하면
<br>

**프로토콜이란?**
<br>

* 일반적으로 통신규약, 통신동작의 규칙을 정한 것이라는 개념이다.
* 예: http, https, ftp(파일 업로드나 다운로드할 때 사용하는 프로토콜), mailto(메일 송신 관련 프로토콜) 등.
<br>

**도메인 이름이란?**
<br>

* 한마디로 서버의 이름. http, ftp에서 사용되며 액세스하는 서버의 이름이다.
* 해당 구간은 IP주소로 대체할 수도 있는데 이에 대한 내용은 DNS에서 추가로 설명하겠다.

<br>

**경로란?**
<br>

* 앞에서 도메인 이름으로 서버에 접속하였다면, 해당 서버에서 내가 원하는 자원의 위치를 표시한 내용이다.
* 서버 내부 루트 디렉토리 하위에 위치한 파일들의 위치를 찾아가는 내용을 담고 있다.
<br><br>


## HTTP
<br>

* Hyper Text Transfer Protocol
* 웹 브라우저와 웹 서버 간에 하이퍼텍스트(Hyper Text) 문서와 관련된 리소스를 주고받을 때(Transfer) 사용하는 통신 규약(Protocol)
<br><br>


## HTTP의 동작 과정
<br>

* HTTP는 웹브라우저(Client)와 웹 서버(Server)간의 일련의 요청과 응답 메시지를 주고 받는 과정이다.
<br>

1. 일반적으로 클라이언트 측에서의 웹 자원의 접근을 요청하기를 원할 때 HTTP가 진행된다. (Ex. URL 입력)
<br>

2. 클라이언트(브라우저 측)에서 HTTP 요청 메시지를 생성하여 서버에 전송한다.
  - 요청 메시지 구성 요소
    1. 메서드
    2. URI (= URL)
    3. HTTP 버전 (1.0 or 1.1)
    4. 헤더
    5. 본문
<br>

3. 서버는 요청메시지를 받고 해석하여 응답 메시지를 생성하여 클라이언트 측에 전송한다.
  - 응답 메시지 구성요소
    1. 스테이터스 코드
    2. HTTP 버전
    3. 헤더
    4. 본문
<br>

4. 클라이언트에서 응답을 처리한다.
<br><br>


## IP 주소
<br>

*IPv4 (Internet Protocol version 4)*:
  * 현재 가장 널리 사용되는 IP 주소 형식.
  * 32비트로 구성되어 있으며, 네 개의 8비트 숫자로 나누어져 있다.
  * 각 숫자는 0에서 255 사이의 값으로 구성된다.
  * 예: 192.168.1.1
<br>

*IPv6 (Internet Protocol version 6)*:
  * IPv4 주소의 고갈 문제를 해결하기 위해 도입된 새로운 IP 주소 형식.
  * 128비트로 구성되어 있으며, 8개의 16비트 그룹으로 나누어져 있다.
  * 각 그룹은 4자리의 16진수와 콜론(:)으로 표현한다.
  * 예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
<br><br>


## TCP/IP 네트워크
<br>

* TCP/IP (Transmission Control Protocol/Internet Protocol) 네트워크는 TCP와 IP 프로토콜을 기반으로 한 디지털 네트워크 체계이다.
* 이는 인터넷의 핵심 구성 요소로, 각기 다른 네트워크와 기기들을 연결하여 통신을 가능하게 하는 표준 프로토콜 스택이다.
<br>

* *계층적 구조*: 
  * TCP/IP는 여러 계층으로 구성되어 있다.
* *응용 계층 (Application Layer)*:
  * 사용자와 가장 가까운 계층으로써, 웹 브라우징, 이메일 전송, 파일 전송 등의 응용 프로그램이 이 계층에서 동작한다.
* *전송 계층 (Transport Layer)*:
  * 호스트 간의 데이터 통신을 관리하며, TCP와 UDP 프로토콜이 여기에 속한다.
* *인터넷 계층 (Internet Layer)*:
  * 데이터 패킷의 라우팅과 주소 지정을 담당한다.
  * IP, ICMP, ARP 등의 프로토콜이 이 계층에서 동작한다.
* *네트워크 인터페이스 계층 (Network Interface Layer)*:
  * 물리적 네트워크 하드웨어와 연결되며, 데이터의 프레이밍과 MAC 주소 지정을 담당한다.
* *패킷 기반의 통신*:
  * 데이터는 작은 ‘패킷’ 단위로 나누어져 네트워크를 통해 전송된다.
  * 각 패킷은 독립적으로 라우팅되며, 목적지에서 원래의 순서대로 재조립된다.
* *종단간 통신 (End-to-End Communication)*:
  * TCP/IP는 데이터의 전송이 송신자와 수신자 간에 직접적으로 이루어진다는 원칙을 따른다.
  * 중간에 있는 네트워크 기기들은 패킷의 내용을 변경하거나 해석하지 않는다.
* *주소 체계*:
  * IP 주소는 각 기기를 고유하게 식별하기 위한 주소다.
  * 이 주소는 IPv4 (예: 192.168.0.1) 및 IPv6 (예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334) 형식
* *신뢰성*:
  * TCP는 데이터의 신뢰성 있는 전송을 보장한다.
  * 패킷이 손실되거나 순서가 바뀌면, TCP는 해당 패킷을 재전송하게 된다.
* *다양한 응용 프로토콜 지원*:
  * HTTP (웹), FTP (파일 전송), SMTP (이메일) 등 다양한 응용 프로토콜이 TCP/IP 위에서 동작한다.

<br><br>

## HTTP의 기본
<br>

Hyper Text Transfer Protocol의 약어
웹 브라우저와 웹 서버간에 문서, 이미지, 비디오 등의 리소스를 주고 받는 통신 규약이다.
<br>

그렇다면 서버와 브라우저 간의 HTTP 통신은 어떻게 이루어지는가?
<br>

기본적으로 서버와 브라우저 2개의 존재가 있다고 하였을 때
<br>

1. 브라우저에서 Request 메시지를 전송한다.

여기서 이 Request 메시지 정보에는 2가지가 담기는데, URI(Uniform Resource Identifier)와 메서드이다.
<br>

리퀘스트 메시지 안에는 "무엇을","어떻게" 해서라는 내용이 써져있다.
여기서 "무엇을"이 URI, 어떻게를 메서드가 담당한다.
<br>

> 여기서 URI는 URL과 URN이라는 두 가지 범주를 지니고 있다. <br>
> URN은 URN (Uniform Resource Name): 자원의 고유한 이름을 제공하지만 그 위치나 방법에 
> 대해서는 제공하지 않습니다. URN은 자원이 어디에 위치하는지나 어떻게 접근해야 하는지에 대한 정보 
> 없이 그 자원을 유일하게 식별하는 데 사용됩니다.<br>
> 예: urn:isbn:0451450523 (특정 책의 ISBN 번호를 나타냄)

<br>

2. 웹 서버는 Request에 요구사항에 따른 Response 메시지를 반환한다.

리퀘스트 메시지가 웹서버에 도착하면 웹서버는 그 정보를 토대로 URI와 메서드를 통해 동작하고, 응답 메시지를 반환한다.
<br>

여기서 반환과정에서 스테이터스 코드를 반환하게 되는데

## 스테이터스 코드란? (Status Codes) 
<br>

* 서버가 클라이언트의 요청에 대한 응답으로 보내는 숫자 코드. 응답의 성공, 실패, 오류 등의 상태를 나타낸다.
<br>

- 1XX (Informational)
    - 거의 사용되지 않음
- 2XX (Successful)
    - 클라이언트의 요청을 성공적으로 처리
        - 200 OK
            - 요청 성공
        - 201 Created
            - 요청 성공해서 새로운 리소스가 생성됨
        - 202 Accepted
            - 요청이 접수되었으나 처리가 완료되지 않았음
        - 204 No Content
            - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음.
            - ex)save버튼의 결과로 아무 내용이 없어도 된다.
- 3XX(Redirection)
    - 웹브라우더는 3xx응답의 결과에 Location 헤더가 있으면, Location위치로 자동이동
        - 300 Multiple choices
        - 301 Moved Permanently
        - 302 Found
        - 303 See Other
        - 304 Not Modified
        - 307 Temporary Redirect
        - 308 Permanent Redirect
- 4XX(Client  Error)
    - 클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없음
    - 오류의 원인이 클라이언트에 있음
    - 클라이언트가 이미 잘못된 요청 데이터를 보내고 있기 때문에 똑같은 재시도가 실패함
        - 400 Bad Request (백엔드와 프엔 개발자가 제대로 처리를 해야 한다)
            - 요청구문 메시지 오류
        - 401 Unauthorized
            - 인증되지 않음
        - 403 Forbidden
            - 인증 자격 증명은 있지만 접근권한이 불충분한 경우
        - 404 NotFound
            - 요청 리소스가 서버에 없음
- 5XX(Server Error)
    - 서버 내부 문제로 오류 발생
    - 서버에 문제가 있기 때문에 재시도 하면 성공할수도 있음(복구될경우)
    - **서버가 터진게 아닌이상 500메서드 사용을 하면 안됨(심각한 문제에만 사용)**
        - 500 Internal Server Error
            - 서버 내부 문제로 오류발생
        - 503 Service Unavailable
            - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
            - Retry-After헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있다.

<br>

### 메서드의 종류
<br>

메서드 (Methods): HTTP 요청의 종류를 나타내는 행동들.
<br>

* GET: 리소스를 요청합니다.
* POST: 서버에 데이터를 전송하여 리소스를 생성/변경합니다.
* PUT: 리소스를 생성하거나 덮어씁니다.
* DELETE: 리소스를 삭제합니다.
* HEAD: 리소스의 헤더만 요청합니다.
* OPTIONS: 리소스가 지원하는 통신 옵션을 요청합니다.
* PATCH: 리소스의 부분적인 수정을 요청합니다.
<br>
<br>

## HTTP 리퀘스트 메시지와 응답 메시지
<br>

* HTTP의 메시지는 리퀘스트 라인, 메시지 헤더, 메시지 본문 이 3개로 구성되어 있다.
<br>

- 리퀘스트 라인
  * 메소드 + URI + HTTP 으로 구성되어 있어 대략적인 API 구성을 알 수 있습니다.

- 메시지 헤더
  * 한 행에서 한 개의 헤더필드를 입력합니다. 
  * 리퀘스트의 다양한 부가적인 정보를 알 수 있습니다.

- 메시지 본문
  * 클라이언트에서 서버에 송신하는 데이터이며, POST 메서드 사용의 경우 데이터가 들어가는 부분입니다.
<br>

응답 메시지로는 메시지 헤더와 본문은 동일하고 스테이터스 라인이 온다.

- 스테이터스 라인
  * HTTP 버전 + 스테이터스 코드 + 응답문구로 구성되어 있다.

- 메시지 헤더
  * 응답과정에서의 부가적인 정보를 담고 있다.

- 메시지 본문
  * 서버에서 클라이언트에 송신하는 데이터, 파일에서 읽어들인 데이터와 CGI 애플리케이션이 출력한 데이터가 들어간다.
  * 메시지 본문은 바이너리 데이터로 취급된다.
<br><br>

> 바이너리 데이터란?
> 0과 1의 이진숫자로 표현되는 데이터 <br>
> 특징으로는
> * 비텍스트 데이터: 바이너리 데이터는 텍스트 데이터와 달리, 일반 텍스트 편집기로 직접 읽거나 
> 수정하기 어렵습니다. 이미지, 오디오, 실행 파일, 압축 파일 등의 형태로 주로 활용된다. <br>
> * 효율적인 저장: 데이터는 그것의 원래 형태로 직접 저장되므로 종종 바이너리 형식은 텍스트 형식보다 
> 훨씬 효율적이다. <br>
> * 손상의 위험: 바이너리 데이터의 경우 잘못된 수정이나 깨진 부분이 있으면 전체 파일이 손상될 위험이 
> 있습니다. 따라서 바이너리 파일을 직접 편집할 때는 주의가 필요하다. <br>
<br>

예시:
이미지 파일 (JPEG, PNG, GIF 등)
오디오 파일 (MP3, WAV 등)
비디오 파일 (MP4, AVI 등)
실행 파일 (EXE, DLL 등)
압축 파일 (ZIP, RAR 등)

<br><br>

## IP 주소
<br>

* 기본적으로 브라우저는 URL을 해독하거나 HTTP 메시지를 만들 수 있지만, 메시지를 네트워크에 송출하는 기능은 OS를 통해 송신합니다.
* 이때 URL 안에 쓰여있는 서버 도메인 이름을 활용하여 IP 주소를 조사합니다.
* OS에 송신을 의뢰할 때는 도메인명이 아니라 주소로 메시지를 받을 상대를 지정해야 하기 때문이다.
<br>

그러다면 이 IP의 기본 개념에 대한 예시이다.
<br>

허브에 몇 대의 PC를 연결한 서브넷이라는 단위를 기본으로 생각한다.
<br>

이 서브넷을 라우터에 연결하여 점차 트리 여러 서브넷과 같은 허브와 PC로 이루어진 서브넷, 허브와 라우터로 이루어진 서브넷이 형성되고, 이러한 서브넷들을 연결하여 네트워크 전체가 구성된다.
<br>

그리고 ㅁㅁ동 ㅁㅁ번지라는 형태의 네트워크의 주소를 할당합니다.
ㅁㅁ동과 같은 동의 해당하는 것은 서브넷에 할당하고, ㅁㅁ번지등 서브넷에 연결된 각 PC에 고유한 네트워크 번호라 하고, 번지에 해당하는 번호를 호스트 번호, 이 두 주소를 합쳐 IP주소라고 한다.
<br><br>


* 서브넷 (Subnet)
  * 서브넷은 IP 네트워크를 더 작은 단위로 분할한 것입니다.
  * 예를 들어, 큰 기업이 여러 지점을 갖고 있다면, 각 지점은 자체 서브넷을 가질 수 있습니다. 
  * 서브넷을 사용하면 IP 주소 공간을 효율적으로 사용하고, 네트워크 관리를 더 간편하게 할 수 있다.
<br>

* 서브넷 마스크 (Subnet Mask) / 넷마스크 (Netmask)
서브넷 마스크는 IP 주소의 어느 부분이 네트워크 주소를 나타내고 어느 부분이 호스트 주소를 나타내는지 구분해주는 값이다. IPv4 환경에서 서브넷 마스크는 보통 점으로 구분된 4개의 숫자로 표현됩니다.
<br>

예: IP 주소가 192.168.1.10이고 서브넷 마스크가 255.255.255.0인 경우, 192.168.1은 네트워크 주소를 나타내고 .10은 해당 네트워크 내의 특정 호스트를 나타낸다.
<br><br>


## DNS를 사용하는 이유
<br>

IP 주소는 고유한 번호이고 일일이 번호를 기억하기 어렵다는 단점이 있다.
그렇다고 해서 서버명을 IP주소 처럼 사용하자니 문자열에 대한 데이터 운반비용이 비대해지는 문제가 있다.
<br>

그렇기에 사람은 이름을 사용하고 라우터는 IP 주소를 사용하는 방식을 운용하게 되었는데, 그것이 **DNS**이다.
<br>

> DNS (Domain Name System) <br>
> 인터넷에서 도메인 이름을 IP 주소로, 또는 IP 주소를 도메인 이름으로 변환해주는 시스템
<br>

그렇다면 DNS 서버에 조회과정에 대해 알아보자
간단하게 생각하면 DNS 서버에 조회메시지를 보내고 거기서 반송되는 응답 메시지를 받는 것이다.
<br>

이는 DNS 서버는 클라이언트의 동작으로부터 시작된다는 것을 알 수 있는데, 이 과정에서 리졸버라 불리는 과정이 있다.
<br>

DNS 리졸버 (DNS Resolver)는 도메인 이름을 IP 주소로 변환하는 요청을 처리하는 프로세스나 소프트웨어를 지칭한다.
<br>

그리고 이 과정을 name resolution이라고 한다.
<br><br>


### Socket라이브러리 기능, Resolver
<br>

이 리졸버는 Socket 라이브러리에 들어있는 부품화한 프로그램이라고 하는데,
Socket 라이브러리란, 네트워크의 기능을 호출하기 위한 프로그램의 일부라고 생각하면 좋다.
<br>

간단히 말해서 DNS 서버에 요청을 할 때 브라우저는 Socket 라이브러리의 gethostbyname이라는 함수에
서버명을 넣어서 보내주면 IP 주소의 응답을 받을 수 있다.
<br>

자세한 세부동작으로는 HTTP의 리퀘스트 동작과 매우 유사하다.
<br>

1. "~~~"이라는 서버의 IP주소를 알려주세요 라는 요청을 만들어서 DNS서버에 보낸다.
단, 이 메시지의 동작에서는 리졸버가 스스로 동작하는 것이 아닌 OS 내부의 **프로토콜 스택**을 호출하여 실행을 의뢰한다.
*(리졸버는 브라우저와 같이 네트워크의 데이터를 송수신하는 기능이 없기 때문)*
<br>

2. 리졸버가 프로토콜 스택을 호출하면 제어가 리졸버에게 넘어가고 여기에서 메시지를 보내는 동작을 진행한다. LAN 어댑터를 타고 DNS 서버로 송신된다.
<br>

3. DNS 서버에서는 요청에 맞는 응답을 클라이언트에 전송합니다. 프로토콜 스택을 경유하여 리졸버에 건네지고 리졸버는 응답을 해석하여 IP 주소를 메모리에 저장합니다.
<br>

그렇다면 이 DNS 서버에 메시지를 송신할 때의 DNS 서버의 IP주소는 어떻게 아는가?
이것은 TCP/IP 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있으므로 특별히 조사할 것 없이
컴퓨터 설정에서 확인이 가능하다.
<br><br>


## Chrome 주소창에 https://www.naver.com 입력하면 어떤 과정이 일어나나요?
<br>

> chrome 브라우저에서 주소창에 적인 URL(https://www.naver.com)을 해석하기 시작하고 <br>
> 브라우저는 소켓 라이브러리 중 일부인 DNS 리졸버를 활용하여 컴퓨터에 저장된 DNS 서버 API 주소로 <br>
> 요청을 보내 IP주소를 받아와서 메모리에 네이버에 대한 IP 주소를 저장해둔다. <br>
> 그리고 브라우저는 이 IP를 통해 TCP 통신을 시작한다. 연결과정은 3-wayhandShake 가 진행된다. <br>
> 연결이 완료 후 그에 맞는 https 통신 TLS/HTTPS handShake가 진행된다. <br>
> 이렇게 암호화된 통신 상태가 완료되면 브라우저는 요청 메시지를 생성한다. <br>
> https라는 프로토콜 + http://www.naver.com (URI) + HTTP 1.1 get 메서드를 포함하여 > 
> 요청메시지를 생성한다. <br>
> 그리고 요청 메시지를 네이버 IP 주소 웹서버로 송신하고 서버는 해당 요청을 처리하여, 요청된 웹 
> 페이지의 내용을 암호화하여 브라우저에게 전송한다. <br>
> 브라우저는 데이터를 복호화하고, 화면에 웹 페이지를 렌더링한다. <br>