# 3주차
</br>

## 1. 소켓을 작성한다.
프로토콜 스택 + 네트워크용 하드웨어를 통한 네트워크 방식에 대해  자세히 알아보자 </br>
</br>

계층적인 구조라는 것을 생각했던 것은?

</br>

최상단 애플리케이션 계층에서는
네트워크 애플리케이션과 Socket 라이브러리들이 존재하며 동작과 관리하며, DNS 조회과정이 발생한다.
</br>

OS에서의 프로토콜 스택에서 
TCP를 사용하여 데이터 송수신을 담당하는 부분과 UDP라는 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재하는데.
</br>

### 패킷이란?

- 인터넷에서 데이터를 운반할 때 데이터를 나눈 하나의 형태
</br>



### ICMP, ARP
- IP 안에서 이용되는
* ICMP 
  * 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 이용되는 프로토콜
* ARP
  * IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용하는 프로토콜

</br>

### MAC 주소
- IEEE에서 표준화된 LAN 방식의 기기들이 사용하는 주소
</br>

### LAN이 무엇인가?
* Local Area Network"의 약어로, 
  * 한정된 지리적 영역 내에서 컴퓨터 및 기타 네트워크 기기들이 연결되어 있는 네트워크를 가리킨다.
  * LAN은 주로 가정, 사무실, 학교 등 작은 지역 내에서 컴퓨터나 기기들 간의 데이터 통신을 말한다.
</br>


## 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 움직인다.
프로토콜 스택은 내부에 하나의 메모리 영역을 활용하여 통신동작 제어에 필요한 정보를 저장한다.
- 여기서 저장되는 정보는 수신 상대의 IP, 포트 번호, 통신 진행 상태 등이다.
=> 이를 소켓 정보라고 한다.

</br>

프로토콜 스택은 위의 소켓 정보를 활용하여 데이터 통신을 하게된다.
</br>

하지만 이 과정에서 응답이 돌아와야하는데 중간에 응답이 없어지거나 손실되는 경우가 있을 것이다.
그래서 소켓정보에 앞서 말했듯 통신 진행 정보 상태에는 응답이 돌아오는지의 여부와 송신 동작 후의 경과 시간을 확인하여
정보를 포기하거나 다시 보내는 동작을 실행하게 된다.
</br>

> 위에 예시처럼 프로토콜 스택은 소켓에 기록된 제어정보를 참조하여 움직인다.
</br>

### PID
Process ID의 약자로,
각 프로그램을 식별하기 위해 OS가 할당하는 번호
</br>

## Socket 호출 과정
소켓 호출이 이루어지면 프로토콜 스택 내부에서의 동작을 알아보자
</br>

1. UDP 통신을 통한 DNS 서버에서 IP 정보를 받아온다.

2. TCP 통신을 통해 socket 함수 호출 : 소켓 연결

3. TCP 통신을 통한 write 함수 호출 : 데이터 송신

4. TCP 통신을 통한 read 함수 호출 : 데이터 수신

5. TCP 통신을 위한 close 함수 호출 : 연결 끊기
</br>

위의 통신이 시작되면 소켓 한 개 분량의 메모리 영역을 준비합니다

</br>

이러한 메모리 영역을 통해 소켓이 정보를 담아두고 이 위치를 디스크립터를 애플리케이션을 알려주는 과정이 진행된다.
</br></br>

> 애매하니 한번 정리!
> 소켓: 프로세스간 통신이 가능하도록 하는 엔드포인트
> 소켓 정보: 소켓에서 연결되는 IP 등 소켓 통신에 필요한 정보 및 기록을 저장하는 데이터 정보
> 디스크립터: 운영체제에서 소켓 정보를 식별하기 위한 값
</br>

## 서버에 접속한다는 것은 무엇일까?
서버에 접속한다는 것은 클라이언트에서 데이터 송수신 요청을 서버에 보냄을 시작으로,
서버와 클라이언트 간의 제어정보를 주고 받으며, 데이터가 송수신이 가능하도록 하는 상황을 만든다.
</br>

이 과정에서 데이터 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요한데,
이 메모리 영역을 버퍼 메모리라고 한다.
</br>

그리고 이 버퍼 메모리에 대한 확보가 접속 동작이 실행되는데, 
이 실행을 **접속**한다는 의미를 지닙니다.
</br>


## TCP 헤더에는 제어정보를 배치한다.
</br>

위에서 단순하게 송수신 단계에서의 데이터를 제어하는 하는 것을 제어정보라고 표현하였습니다.
이 제어 정보는 TCP 헤더에 기록되는 제어정보는
</br>

- 송신처 포트번호
- 수신처 포트번호
- 시쿼스 번호 : 해당 패킷의 맨 앞의 위치의 데이터가 송신데이터의 몇번쨰 바이트에 해당하는 송신측에서 수신측에 전달하기 위한 정보
- ACK 번호 : 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에서 전달하기 위한 정보
- 데이터 오프셋 : 헤더의 길이
- 사용하지 않음 : 사용하지 않는 필드
- 컨트롤 비트 : 헤더에 대한 각 제어상의 의미를 표시하는 정보
- 윈도우 : 수신측에서 송신측에 윈도우 사이즈를 알리기 위한 정보
- 체크섬 : 오류 유무 검사 정보
- 긴급 포인터 : 긴급 처리할 데이터의 위치
- 옵션 : 필드 외의 추가적인 제어정보 기록
</br>

헤더의 의미는 데이터에 대한 머리로 데이터를 어떻게 처리하면 되는지 알려주는 명세서라고 생각한다면 좋을 것 같다.
데이터 처리 방식 및 접속하는 부분, 에러 사항을 파악하는 정보마저 모두 헤더에 기록되어 있으니
데이터 처리 과정에서는 헤더를 주목하는 것이 데이터 분석에 용이할 것이다.

</br>

> 통신 동작에 이용하는 제어 정보
> * 헤더에 기입되는 정보
> * 소켓에 기록되는 정보



## 데이터 접속 동작의 시작: syn 의미
그렇다면 위의 패킷 정보를 통해 접속을 진행한다고 가정해보자
* 송신 포트번호와 수신 포트번호를 통해 서버측의 소켓을 지정한다.
</br>

이렇게 소켓이 확정되었다면 이제 접속을 시작하는데 이 떄 **SYN**이라는 컨트롤비트를 1로 변경한다.

</br>

> SYN: 컨트롤 비트 중 하나, SYN의 의미는 Synchronize의 약자로 연결 설정을 담당한다.



# 접속의 의미: 3-way handshake
3-way handshake는 TCP 연결을 시작할 때 연결 설정 과정을 설명하는 명칭이다.
3번의 절차를 진행하는데 SYN, SYN-ACK, ACK가 진행된다.
</br>

### 3-way handshake의 순서
</br>

1. SYN: 클라이언트가 서버로 SYN 컨트롤 비트가 담긴 패킷을 전송한다. 이 패킷은 클라이언트가 연결을 시작하고자 함을 알리며, 클라이언트의 초기 시퀀스 번호를 포함한다.

2. SYN-ACK: 서버가 클라이언트로부터의 SYN 패킷을 받으면, SYN과 ACK 컨트롤 비트 설정된 패킷을 클라이언트에 전송한다. 이 패킷은 서버의 초기 시퀀스 번호와 클라이언트의 SYN 패킷에 대한 응답을 포함한다.

3. ACK: 클라이언트가 서버로부터 SYN-ACK 패킷을 받으면, ACK 패킷을 서버에 전송한다. 이 ACK 패킷은 서버의 SYN-ACK 패킷에 대한 응답을 갖고 있다.

</br>

이 3-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 완료되었음을 증명하며, 양쪽의 데이터 전송이 시작될 수 있는 상태가 된다.
이 데이터 통신이 3번의 절차를 통해 데이터 통신에 대한 안정적으로 연결될 수 있는 것이다.

## 연결 해제 소켓 말소: 4-way handshake
4-way handshake는 TCP 연결을 해제할 때 해제 과정을 설명하는 명칭이다.
4번의 절차가 진행되는데 FIN, ACK, FIN, ACK 4번의 절차가 진행된다.
</br>

### 4-way handshake의 순서
</br>

1. FIN: 클라이언트(또는 서버)는 연결을 종료하고자 할 때 FIN(Finish) 플래그가 설정된 패킷을 상대방에게 전송한다. 이는 "더 이상 전송할 데이터가 없으므로 연결을 종료하고자 함"을 의미한다.

2. ACK: 상대방(이 예제에서는 서버)은 FIN 패킷을 받았다는 것을 확인하기 위해 ACK(Acknowledgment) 플래그가 설정된 패킷을 보낸다. 이 패킷은 FIN 패킷에 대한 응답으로, "FIN 패킷을 받았습니다"를 의미한다.

3. FIN: 이제 서버(또는 클라이언트)는 자신의 데이터 전송이 모두 완료되었음을 알리기 위해 FIN 플래그가 설정된 패킷을 클라이언트에게 전송힌다.

4. ACK: 클라이언트는 서버의 FIN 패킷을 받았다는 것을 확인하기 위해 ACK 패킷을 서버에게 보낸다. 이 패킷은 서버의 FIN 패킷에 대한 응답으로, "서버의 FIN 패킷을 받았습니다"를 의미한다.
</br>

이 4-way handshake를 통해 클라이언트와 서버간의 TCP 연결이 안전하게 종료되는 것을 보장하며 
양쪽 모두가 데이터 전송이 완료되었음과 연결이 종료되었음을 알 수 있게 해준다.