# Chapter 1 : 웹 브라우저가 메시지를 만든다 - 웹 브라우저의 내부 탐험

## 1.1. HTTP(HyperText Transfer Protocol) 리퀘스트 메시지를 작성한다

- HTTP란 웹 서버와 클라이언트간의 통신에 사용되는 프로토콜이다.
- 사용자가 URL을 브라우저에 입력할 떄, URL을 해독하는 것 부터 브라우저의 동작은 시작된다.
- URL은 의미에 따라 리퀘스트 메시지를 만들고, 웹서버에 자신이 원하는 동작을 전달한다.

#### 프로토콜(Protocol)

- 규칙을 의미하며, 네트워크에 한정한다면 3가지에 대한 규칙을 의미한다.
- 통신 장치 간에 교환될 메시지의 **형식(Syntax)**, 메시지의 교환 **순서(Timing)**, 교환할 때 수행해야 할 **행위(Semantics)** 이다.

### 1.1.1. 탐험 여행은 URL 입력부터 시작한다

- 브라우저란 웹 서버에서 정보를 가져와 사용자에게 보여주는 클라이언트 소프트웨어이다.
  - Google Chrome, Mozilla Firefox, Apple Safari, Microsoft Edge 등이 있다.
- 데이터의 흐름은 브라우저에 사용자가 URL을 입력하는 것부터 시작된다.

#### URL(Uniform Resource Locator)

- 인터넷 상의 리소스를 고유하게 식별하고 위치를 지정하는 문자열이다.
- 일반적인 URL의 구조는 다음과 같다. [scheme]://[host]:[port]/[path]?[query]
  - scheme : 리소스에 어떻게 접근할 것인지를 나타내며, 대표적으로 http, https, ftp, mailto 등이 있다.
  - host : 리소스가 위치한 인터넷 상의 컴퓨터를 나타낸다. 주로 도메인 이름이나 IP 주소로 표현된다.
  - port : 네트워크 서비스에 접근하기 위한 포트 번호. 지정되지 않는다면 프로토콜의 기본 포트번호가 사용되는데, 대표적으로 http의 기본 포트는 80, https의 기본 포트는 443이다.
  - path : 호스트 내의 리소스 위치를 상세하게 지정한다.
  - query : 리소스에 대한 추가적인 정보나 요청 파라미터를 나타낸다. 보통 key=value 형태로 나열된다.

> 예시
>
> - https://www.example.com/page?id=1
> - scheme : https
> - host : www.example.com
> - port : 명시적으로 적히지 않았으나, https의 기본 포트 443 사용
> - path : /page
> - query : id=1

![각종 URL의 형식](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Fcf09156f-3834-46a5-9c6e-efb60e4a5dcd%2F97B757C7-9C73-4A69-8489-0327E1363982.jpeg)

### 1.1.2. 브라우저는 먼저 URL을 해독한다

- 브라우저가 사용자의 입력을 받고 처음 하는 일은 웹 서버에 보내는 리퀘스트의 메시지를 작성하기 위해 URL을 해독하는 것이다.

![브라우저의 해독 과정 1](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Ff0e18e30-6db9-4947-9803-5c5f9c8ed29a%2F20FD9030-3818-4B53-9511-238022265195.jpeg)
![브라우저의 해독 과정 2](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F4bb21f01-a792-454f-bab4-592e5365c233%2F56A3119C-4B3F-4265-A5D7-6F4F3E21A471.jpeg)

- 위 과정을 보면, www.lab.cyber.co.kr 도메인을 가지는 서버에 접속한다.
- 이후 /dir/file1.html 경로에 있는 파일에 접근한다.

### 1.1.3. 파일명을 생략한 경우

- http://www.lab.cyber.co.kr/dir/ 같은 형태가 존재한다.
- 끝이 /로 끝나는 것은 /dir/ 다음의 파일명을 생략한 것인데, 이런 경우 서버가 설정하는 default 값이 존재한다.
  - 대부분의 서버가 index.html, default.html 이라는 파일명으로 설정한다.

> 예시
>
> - http://www.lab.cyber.co.kr/dir/index.html
> - http://www.lab.cyber.co.kr/dir/default.html

- http://www.lab.cyber.co.kr 와 같이 끝의 / 까지 생략할 수도 있다.

  - 끝의 / 가 생략된 경우, 루트 디렉토리의 아래에 존재하는 서버가 미리 설정한 파일명에 엑세스하게 된다.
- http://www.lab.cyber.co.kr/example 와 같이 경로를 쓰고 끝의 / 가 생략될 수 있다.

  - 맨 끝에 / 가 생략된 경우, 웹 서버에 example이라는 파일이 있으면 파일명으로 보고, 디렉토리가 있다면 디렉토리명으로 본다.

### 1.1.4. HTTP의 기본 개념

- URL을 해독하면 어디에 엑세스 해야하는 지 알 수 있다.
- 해독한 데이터를 바탕으로, 브라우저는 HTTP 프로토콜을 사용하여 웹 서버에 엑세스한다.
- 클라이언트는 서버에게 **무엇을**, **어떻게** 를 포함하여 서버에게 리퀘스트 메시지를 보낸다.

  - 어떻게 : 메소드를 이용하여 서버에게 수행할 동작을 전달한다.
  - 무엇을 : URI를 칭하며, 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일명을 URI로 쓴다.
    - URI란 : URI란 Uniform Resource Identifier의 약자로, 인터넷에서 자원을 고유하게 식별하거나 이름을 붙이는 문자열을 뜻한다.
    - CGI 프로그램 : Common Gateway Interface Program의 약자로, 웹 서버와 독립적인 소프트웨어 어플리케이션 간에 정보를 주고받을 수 있는 방법을 정의한다.

    > 예시
    >
    > - 사용자가 웹 브라우저를 통해 어떤 폼을 채우고 '제출' 버튼을 누르면 웹 서버는 이 정보를 CGI 프로그램에 전달하고, 프로그램은 이 데이터를 처리하고, 처리된 결과를 HTML 형태로 웹 서버에 전달한다.
    >

![HTTP의 주요 메소드](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F911e3a3a-5ce9-4780-8b54-8fb43588fc48%2F7A9ECDC9-96AC-4A23-8D19-23C2793084BE.jpeg)

- 서버는 메시지를 판단한 후 요구에 따라 동작하고, 결과 데이터를 응답 메시지에 저장한다.
- 응답 메시지의 맨 앞 부분에는 실행 결과를 나타내는 status code가 있다.
  - 웹 서버에 엑세스 했을 때 '404 Not Found'와 같이 표시될 수 있는데, 404가 status code이며 Not Found는 상태 문구라 칭한다.

#### 상태 코드(Status Code)

- 상태 코드는 요청이 성공적으로 완료됐는지 알려주는 역할을 한다.
- 상태 코드는 5개의 그룹으로 묶여있다.

| 상태 코드 값 | 설명                                |
| ------------ | ----------------------------------- |
| 100 ~ 199    | 처리의 경과 상황 등을 통지한다      |
| 200 ~ 299    | 요청이 성공적으로 완료됐음을 알린다 |
| 300 ~ 399    | 다른 조치가 필요함을 나타낸다       |
| 400 ~ 499    | 클라이언트 오류를 나타낸다          |
| 500 ~ 599    | 서버 오류를 나타낸다                |

### 1.1.5. HTTP 리퀘스트 메시지를 만든다

- URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP 리퀘스트 메시지를 생성한다.

![HTTP 메시지 포맷](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F5115e299-50a6-46de-9a6c-cacc499da474%2FC69846C6-6EE0-44D3-8F68-A0B99967E522.jpeg)

- 리퀘스트 메시지의 포맷은 이미 정해져 있고 다음과 같은 요소로 이루어져있다.
  - 리퀘스트 라인
    - 서버에게 어떤 동작을 취해달라 요청하는 메소드가 들어간다.
    - URI를 통하여 타겟이 되는 데이터를 보낸다.
  - 메시지 헤더
    - 날짜, 데이터의 종류 등 메시지의 부가적인 내용이 들어간다. 공백 행까지가 메시지의 헤더가 된다.
    - HTTP 헤더에 대한 상세한 정보는 [링크](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)를 참고한다.
  - 메시지 본문
    - 메시지 헤더 뒤 공백 이후의 부분을 뜻한다.
    - 메소드가 GET인 경우 메소드와 URI만으로 웹 서버가 무엇을 할지 판단할 수 있어 송신 데이터를 쓰지 않는 경우도 있다.
    - 보통 POST 메소드인 경우, 폼에 입력한 데이터 등을 메시지 본문 부분에 쓰게된다.

### 1.1.6. 리퀘스트 메시지를 보내면 응답이 되돌아온다

- 리퀘스트의 경우 실행 결과를 나타내는 스테이터스 코드와 응답 문구가 첫 번째 행에 들어간다.
  - 스테이터스 코드는 숫자로 이루어져 있으며, 주로 프로그램 등에 실행 결과를 알려주는 것이 목적이다.
  - 응답 문구는 사람에게 실행 결과를 알리는 것이 목적이다.
- 페이지가 문장으로만 되어있다면 전송의 끝이다.
- 만약 이미지, 비디오 등의 추가 리소스를 포함하고 있다면 이러한 리소스에 대한 태그가 문장안에 들어간다.
  > 예시로 ' img src="image.jpg" ' 는 이미지 파일에 대한 태그이다.
  >
- 브라우저는 이러한 태그를 해석하여 해당 리소스에 대한 추가 HTTP를 서버에 전송하는데 원래의 html 문서와 별도로 "image.jpg" 라는 이미지 파일을 요청하는 새로운 HTTP 리퀘스트가 발생한다.
- 브라우저는 나누어 받은 리퀘스트가 한 페이지인지 여러 페이지인지 모르며, 단순히 하나의 요청에 대해 하나의 응답만 돌려보낸다.
- 모든 필요한 리소스가 브라우저에 로딩되면, 브라우저는 이들을 이용하여 웹 페이지를 완성한다.

![HTTP 메시지의 예시 1](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F81d21c50-e1e6-49d7-b43c-2eaabd5377ab%2FB32BF220-D4B8-4CBB-BF49-95E6DE681608.jpeg)
![HTTP 메시지의 예시 2](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F05c79b83-c7de-4e57-ba9b-7afa64c93975%2FE57693FA-495F-4344-B421-7E00EC9565C3.jpeg)
![HTTP 메시지의 예시 3](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F6a6193b6-3e51-4e14-a46f-a28aea436cdd%2FAAE3712B-C831-4992-B39B-CE408A950AB3.jpeg)

### 1.1.7. 정리

- 웹 브라우저의 기본 작업은 사용자가 입력한 URL을 바탕으로 HTTP 리퀘스트 메시지를 생성하고, 서버로부터 받은 응답을 처리하여 화면에 출력한다.

## 1.2. 웹 서버의 IP 주소를 DNS 서버에 조회한다

- 브라우저는 URL을 해독하거나 HTTP 메시지를 만들 수 있지만, 이를 송출하는 기능은 없다.
- 따라서 상대방의 IP 주소를 이용하여 운영체제를 통해 웹 서버에 메시지를 송신한다.

### 1.2.1. IP 주소의 기본

#### IP

- IP주소는 네트워크 번호와 호스트 번호를 합쳐 부르는 것이다.
  - 네트워크 번호 : 특정 네트워크를 식별하는 번호이다.
    - 여러 네트워크가 있을 때, 어떤 네트워크에 특정 호스트가 위치하는지 알 수 있다. 라우터는 이 정보를 사용하여 패킷을 올바른 네트워크로 전달한다.
  - 호스트 번호 : 특정 네트워크 내에서 개별 호스트를 식별한다.
    - 네트워크 번호가 같은 여러 호스트 중 어떤 하나를 구체적으로 지칭할 때 사용된다.

#### 네트워크

- 연결된 장치들의 집합을 뜻한다.
- 데이터를 공유하거나 전송할 수 있으며, 이러한 과정은 통신 프로토콜을 통해 이루어진다.

#### TCP

- 인터넷 통신을 위한 프로토콜이다.
- 신뢰성 있는 데이터 전송을 지향하는 프로토콜이다.
- 이 프로토콜을 사용할 시 전화를 거는 것처럼 상대와 연결을 설정하고 통신을 시작하는데, 이 과정을 3-way-handshake라고 한다.
  - 3-way-handshake
    - 클라이언트가 상대에게 통신을 원한다는 패킷(SYN)을 보낸다.
    - 서버는 그 메시지에 대한 응답 + 나도 통신 준비가 되어있다는 패킷(SYN-ACK)을 보낸다.
    - 클라이언트는 다시 서버에게 패킷(ACK)를 보내 연결을 확정하여 연결을 성립한다.
    - 이런 과정을 통해, 잘못된 연결 요청이나 실제 연결을 방해하는 것을 방지하고, 정확한 통신 시작 시점을 동기화한다.

![3-way-handshake](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkR9BL%2FbtqF633KIKJ%2FsWczOxIOZ8mZ1hRidIQCM0%2Fimg.png)

- [OSI 7계층](https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95)에서 뚜렷하게 구분되기 어려운 부분을 통합해 표현한 것이다.
  - 7계층에 대한 개괄은 [링크](https://shlee0882.tistory.com/110)로 대체한다.
- 서브넷이라는 작은 네트워크를 라우터로 접속하는 형태로 구성된 네트워크이다.

#### 데이터 패킷

- 네트워크를 통해 전송되는 작은 데이터 덩어리를 뜻한다.
- 일반적으로 헤더와 페이로드로 구성되어 있다.
  - 헤더 : 패킷의 메타데이터를 담고 있으며, 목적지 주소, 출발지 주소, 패킷의 길이 등의 정보를 포함한다.
  - 페이로드 : 실제 전송할 데이터가 담겨있다.
- 다양한 네트워크 기기를 거쳐 목적지까지 전송된다. 각 기기에서는 패킷의 헤더를 읽어 적절한 경로를 선택한다.

#### 서브넷

- IP주소 공간을 효율적으로 관리하고, 네트워크 트래픽을 분리하여 성능을 개선하거나 보안을 강화하기 위해 큰 네트워크를 더 작은 네트워크 단위로 분할한 것이다.

#### 라우터

- 네트워크 간의 데이터 패킷을 전달하는 장치로서, 중개하는 역할을 한다.
- 이 장치는 여러 개의 네트워크를 연결하고, IP 주소를 기반으로 패킷의 목적지에 도달할 수 있도록 경로를 선택하는 역할을 한다.

#### 허브

- 여러 개의 이더넷 포트를 가지고 있어, 다양한 컴퓨터나 네트워크 장비를 연결하여 패킷을 중개하는 장치의 일종이다.
- 리피터 허브(Repeater Hub)와 스위칭 허브(Switching Hub)의 두 가지 주요 유형이 있다.
  - 리피터 허브 : 데이터 패킷을 분석하지 않고, 단순히 전기적인 신호를 모든 포트로 중계한다.
  - 스위칭 허브 : 들어오는 데이터 패킷의 목적지를 파악하고 해당 목적지로만 데이터를 전송한다.

![IP의 기본 개념](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F25202761-4de8-41d7-a477-20cc940fcc43%2F77400EAE-D5C6-4B81-8E56-98A5F383161F.jpeg)

#### IP의 동작 순서

1. IP 주소에 따라 액세스 대상이 어디에 있는지 판단한다.
2. 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반한다.
3. 송신측에서 가장 가까운 라우터까지 도착한다.
4. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고, 거기에 보내도록 지시하여 송신 동작을 실행한다.
5. 다시 서브넷의 허브가 라우터까지 메시지를 보낸다.
6. 위 동작을 반복하면 최종적으로 상대의 데이터가 도착한다. 이것이 TCP/IP와 IP 주소의 기본적인 개념이다.

#### IP 주소의 구성

- IP에는 [IPv4](https://ko.wikipedia.org/wiki/IPv4)와, [IPv6](https://ko.wikipedia.org/wiki/IPv6)이 존재하는데, 설명은 IPv4를 기준으로 한다.
- IP주소는 32비트로 구성되어있다.
- 표기는 221.149.9.93 과 같이 8비트씩 끊어서 십진수로 표기하는 십진수 점 표기법(DDN; Dotted Decimal Notation)을 사용한다.
- 32비트의 한계 내에서, 네트워크 ID와 호스트 ID를 구분하여 사용한다.
  - 이때, 우리는 어디서 어디까지가 네트워크 ID인지, 호스트 ID인지 분간할 수 없다.
- 어떤 비트를 네트워크 ID로 사용할 것인가를 위해 사용하는 것이 **서브넷 마스크(Subnet Mask)** 이다.

#### 서브넷 마스크

- IP 주소는 211.149.9.93/24 처럼 IP 주소 뒤에 네트워크 ID의 길이를 표기한다.
- 혹은 DDN이나 이진수로도 표기할 수 있다. 위의 주소를 DDN으로 표기한다면, 255.255.255.0 이다.
  - 네트워크 주소를 사용하는 비트는 전부 1인 것을 뜻한다.

> 예시
>
> - 128.192.174.24/15 의 네트워크 아이디를 알아보자.
>   - IP Address = Network ID(prefix) + Host ID(suffix)
>   - 15는 네트워크 아이디의 길이
>     - 1111 1111 1111 1110 0000 0000 0000 0000 : Subnet Mask
>     - 1000 0000 1100 0000 1010 1110 0001 1000 : IP Address
>     - And연산 진행
>     - 1000 0000 1100 0000 0000 0000 0000 0000 : Network ID
>   - 따라서 128.192.0.0 이 네트워크 아이디에 해당한다.
>   - 나머지 17개의 비트를 사용해서 2의 17승의 갯수만큼 호스트가 존재할 수 있다.

#### 특별한 IP 주소

- 네트워크 주소 : 네트워크를 나타내는 주소로 호스트 ID의 모든 비트가 0이다.
- 브로드캐스트 주소 : 네트워크에 속한 모든 호스트에게 데이터를 전송하기 위한 주소로 호스트 ID의 모든 비트가 1이다.
- 와일드카드 주소 : 0.0.0.0/0 주소를 말하며, 모든 IP를 지칭한다.
- 루프백 주소 : 로컬 머신을 지칭하는 주소로 127.0.0.0/8을 사용한다. 로컬호스트라고도 한다.

### 1.2.2. 도메인명과 IP 주소를 구분하여 사용하는 이유

- TCP/IP 네트워크는 IP 주소로 상대를 특정한다. 따라서 URL을 서버명이 아니라 IP 주소를 써도 올바르게 작동한다.
- 하지만 단순히 숫자로서 기억하기에는 어렵다. 따라서 도메인을 이용하여 서버를 찾아가는 방법이 고안되었다.

#### DNS(Domain Name System)

- 우리는 인터넷을 이용할 때 IP주소를 직접 입력하지 않고 일련의 문자열을 입력한다.
- 기억하기 어려운 숫자대신 문자열을 입력하여 특정 호스트에 접속할 수 있게 하는 것이 DNS의 역할이다.
- www.naver.com 같은 이름을 도메인 이름이라 한다.
  - 중간의 naver같은 이름을 Label이라 한다.
- 도메인은 논리적 계층단위이다.
- 점(.)으로 상위 계층과 하위 계층을 구분하여 상위 계층을 오른쪽에 작성한다.
- 각 도메인은 최상위 도메인인 루트 도메인(Root Domain)을 제외하고 알파벳으로 표현, 루트로부터 최대 128개의 레벨을 가질 수 있다.
- 전 세계의 도메인 관리는 ICANN이, 국내는 KRNIC가 관리하고 있다.

![도메인 이름 예시](https://velog.velcdn.com/images%2Fclaraqn%2Fpost%2Fd984fcff-990c-4c38-b28f-089e64796712%2Fimage.png)

### 1.2.3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다

- IP 주소를 얻는 과정은 가장 가까운 DNS 서버에 도메인을 건네고, 해당하는 IP 주소를 반환 받기 위한 질의-응답 과정을 거친다.
- DNS 서버에 도메인 이름을 조회할 때, 우리의 컴퓨터는 이 과정에서 DNS 서버의 '클라이언트' 역할을 한다.
- 이 DNS 클라이언트에 해당하는 것을 DNS **리졸버** 또는 단순히 **리졸버** 라고 부른다.
- DNS의 원리를 사용하여 IP 주소를 조사하는 것을 **네임 리졸루션(name resolution)** 이라 하며, 이 네임 리졸루션을 실행하는 것이 리졸버다.
- 리졸버는 Socket 라이브러리에 들어있는 모듈화한 프로그램이며, Socket 라이브러리는 네트워크의 기능을 호출하기 위한 프로그램의 모듈들을 뜻한다.
  - Socket 라이브러리는 운영체제에 내장되어 있거나, 프로그래밍 언어의 표준 라이브러리에 포함되어 있다.

#### C++과 C#에서 지원되는 네트워크 라이브러리

- C++
  - [Boost.Asio](https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio.html) : 네트워킹 및 기타 I/O 작업을 위한 C++ 라이브러리. 크로스 플랫폼 호환성이 있다.
  - [libcurl](https://curl.se/libcurl/) : HTTP, FTP 등을 지원하는 C 라이브러리. C++에서도 널리 사용된다.
  - [WebSocket++](https://docs.websocketpp.org/) : 웹 소켓을 사용하기 위한 C++ 라이브러리.
  - [Poco C++ Libraries](https://pocoproject.org/) : 네트워킹뿐만 아니라 XML 파싱, 파일 처리 등 다양한 기능을 제공하는 크로스 플랫폼 C++ 라이브러리이다.
  - [Qt Network](https://doc.qt.io/qt-6/qtnetwork-index.html) : Qt 프레임워크의 일부로, 소켓 프로그래밍, HTTP 클라이언트 및 서버, FTP 등을 지원한다.
- C#
  - [System.Net](https://learn.microsoft.com/en-us/dotnet/api/system.net?view=net-7.0) : .NET 프레임워크와 .NET Core에서 기본적으로 제공하는 네트워크 관련 클래스 라이브러리이다. HTTP, FTP, SMTP, DNS 등을 지원한다.
  - [HttpClient](https://learn.microsoft.com/ko-kr/dotnet/api/system.net.http.httpclient?view=net-7.0) : .NET에서 HTTP 클라이언트 작업을 수행하기 위한 라이브러리이다.
  - [WebSocket](https://learn.microsoft.com/ko-kr/dotnet/api/system.net.websockets.websocket?view=net-7.0) : .NET에서 제공하는 웹소켓 API이다.
  - [gRPC](https://grpc.io/) : 고성능, 오픈소스, 범용 원격 프로시저 호출(RPC) 프레임워크이다. C# 뿐 아니라 타 언어 또한 지원한다.
  - [RestSharp](https://restsharp.dev/) : RESTful API를 쉽게 호출할 수 있게 해주는 간단하고 라이브러리이다.
  - [ZeroMQ](https://zeromq.org/) : 메시지 큐 라이브러리로, 다양한 메시징 패턴을 사용할 수 있다.

### 1.2.4. 리졸버를 이용하여 DNS 서버를 조회한다

- Socket 라이브러리에 들어있는 프로그램은 모듈화 되어있고 호출하여 간단하게 사용할 수 있다.

![리졸버를 호출하는 방법](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2F829d0d2f-c43d-4850-a9a1-64ef40514e40%2F2D833B6E-0291-49C6-A8B4-9C1FC4F25AE3.jpeg)

- 이렇게 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아온다.
- 이 응답 메시지 속에 IP주소가 포함되어 있고 리졸버는 이것을 추출하여 브라우저에서 지정한 영역에 삽입한다.
- 이렇게 메모리 영역에 존재하는, 추출된 IP 주소를 HTTP의 리퀘스트 메시지와 함께 운영체제에 건네주어 송신을 완료한다.

### 1.2.5. 리졸버 내부의 작동

1. 1.2.4. 의 과정을 거치면, 호출된 리졸버에게 실행 흐름이 넘어간다.
2. 리졸버에 제어가 넘어가면 DNS 서버에 문의하기 위한 메시지를 만든다.프로토콜 스택(protocol stack)은 네트워크 통신을 가능하게 하는 여러 프로토콜의 집합입니다.

- 브라우저가 웹 서버에 보내는 HTTP의 리퀘스트 메시지를 만드는 것과 유사하다.
- 하지만 HTTP는 메시지를 문자로 쓰지만, DNS의 메시지는 바이너리 데이터로 표현된다.

3. 메시지의 송신은 리졸버가 아니라 운영체제 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰한다.
4. 리졸버가 프로토콜 스택을 호출하면 메시지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
5. 조회 메시지는 DNS 서버에 도착하고, DNS 서버는 메시지에 쓰여 있는 데이터를 토대로 조사하여 값을 반환한다.
6. 메시지는 네트워크를 통해 클라이언트측에 도착, 프로토콜 스택을 경유하여 리졸버에 건네져 IP 주소를 다시 추출하여 애플리케이션에 값을 건네준다.
7. 이렇게 리졸버의 동작이 끝나고 제어가 브라우저에게 돌아오게 된다.

![리졸버를 호출할 때 PC 내부의 동작](https://velog.velcdn.com/images%2Fsixhustle%2Fpost%2Ff6f2a5f5-afea-4ea4-a971-dc62888ecbc5%2F483C5678-86AA-48F5-8BC6-6C2614720E3B.jpeg)

#### 프로토콜 스택(Protocol Stack)

- 프로토콜들이 계층적으로 쌓여 있는 구조를 의미하며, 각 계층은 특정한 기능을 수행한다.
- OSI 7계층이나 TCP/IP 4계층과 같은 모델을 구체적으로 구현한 것이라고 볼 수 있다.
  - 모델들은 이론적인 또는 추상적인 레이어링을 제공하지만, 프로토콜 스택은 실제로 소프트웨어로 구현된 각 계층의 모음이다.

---

# 참고자료

- [Protocol Stack - Wikipedia](https://en.wikipedia.org/wiki/Protocol_stack)
